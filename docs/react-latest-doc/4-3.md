# Fiber 介绍



Fiber为React提供下一代的核心算法，包括：

- 增量渲染（将渲染工作拆分，切片，分批执行）
- 暂停、终止、恢复渲染
- 为渲染任务增加优先级
- 为React扩展并行特性



## Element到 FiberNode

一个React的组件函数返回的是ReactElement，例如：

```tsx
function SomeComponent(){
    return <div>...</div>
}
```

JSX会被解析成`React.createElement` 。

ReactElement不能自己完成渲染，这个时候，我们需要`render` 。例如`ReactDOM` ：

```tsx
ReactDOM.render(<SomeComponent />, document.getElementById("foo"))
```

`<SomeComponent />` 的结果是ReactElement。ReactElement只是数据，不能完成渲染，具体可以参考上一节内容。

真实的渲染工作，在`render` 函数中，需要构造一个特殊的概念——Fiber。Fiber负责完成具体的工作：

### 什么是Fiber

简单说，Fiber是React的下一代算法核心。 Fiber代表的是一份需要完成的工作，例如进行domDiff，然后更新。

Fiber = Work

**Work（工作）**

React需要进行的计算。例如setState调用后，产生新的VirtualDOM，需要进行DOM-DIFF。

可以将一个 Work理解成一个没有被调用的函数，等待被执行。

总结下，createElement返回的是数据 （ReactElement），想让ReactElement渲染，需要做工(Work/Fiber)。

Fiber就像一个函数一样， 当执行Fiber 时，ReactElement最新的状态就会同步到DOM。



## Fiber的调用栈



React组件渲染是一次函数调用。

```tsx
view = f(data)
```

例如下面这个组件:

```tsx
function App() {
    return <Page>
        <Header />
        <Body>
            <Table />
        </Body>
    </Page>
}
```

实际上构成了多次函数调用，第一次是`App` ，然后是`Page` ， 然后是`Header` ，然后是`Body` ，然后是`Table` 。

如果要用`ReactDOM.render` 绘制`<App />` ，可以认为这是一份工作(Fiber)，也可以认为这是由多个`Fiber` 组成。React选择了后者，`render` 会为每个组件的渲染都创造一个`Fiber` 。

如果按照深度优先搜索的顺序，实际渲染的过程就会构成了一个调用栈：

| Stack               |
| ------------------- |
| FiberNode ： App    |
| FiberNode ： Page   |
| FiberNode ： Header |
| FiberNode ： Body   |
| FiberNode ： Table  |



React为什么不只为APP创造一个Fiber ？ 

- 如果这样，页面渲染就变成了完整的程序，这样可能会因为JS执行时间过程而卡顿

React能够将每一个组件的更新都抽象成Fiber，Fiber之间的执行互不干扰，这样就实现了并发的渲染。

那么，如果只有组件`Body` 发生更新的时候（例如Body中用户调用了setState)，那么React就只需要找到Body对应的Fiber，并重新创造一个新的Fiber代表这次变更。这部分我们后文中讨论。



### 小节

- React组件函数递归执行返回的是一个React Element
- 当要渲染这个React Element时，就需要Fiber



### Fiber的结构



设计上，Fiber是一个节点，在React内部类型是FiberNode。

FiberNode需要描述3件事：

- 具体的工作内容（更新函数）
- 拷贝ReactElement中所有的信息
- 工作和工作之间的顺序关系

### key 和 type



Fiber会拷贝ReactElement中的多个成员。



// 伪代码

```tsx
class FiberNode {
    key : null | string
    elementType : React.ElementType   
}
```

### FiberNode关系



`child` 和`parent` 是FiberNode从ReactElement中克隆的关系。例如：

```tsx
function Foo(){
    return <Bar />
}
```

这个函数渲染过程中会产生两个Fiber。FiberNode(Foo)是FiberNode(Bar)的Parent, FiberNode(Bar)是FiberNode(Foo)的child。

比如这样：

// 伪代码

```tsx
class FiberNode {
    key : null | string
    elementType : React.ElementType   
    
    parent :FiberNode
    child : FiberNode
}
```

对于`parent` ，FiberNode中有一个成员叫做`return` ，`return` 是FiberNode处理完成之后返回的FirberNode。FiberNode就好像函数一样，`return` 代表它的返回值。



因此真实的 FiberNode设计中，有`return` 和`child` 

//  伪代码

```tsx
class FiberNode {
    key : null | string
    elementType : React.ElementType   
    
    return :FiberNode
    child : FiberNode    
}
```

当一个

### 完成。

**(Scheduling)调度**

决定Work什么时候被完成。

思考：为什么不把所有工作(work)顺序执行，而是用调度器调度？ 

*例如一个屏幕上用户看不到部分的渲染优先级应该比可见部分低；当用户输入时，对输入组件的渲染会高于其他组件。在UI设计中，并不是每次更新都需要马上完成，不同的更新会有不同的优先级，一个动画的优先级可能会超过网络请求。*

思考：这种渲染顺序，到底交给框架还是用户呢？

